#!/usr/bin/perl



=head1 No ledge
Structured knowledge database in a wiki-like HTML format.
=cut



# Imports
use warnings;
use strict;
use Getopt::ArgParse;
use File::Find;
use File::Copy;
use File::Path 'make_path';
use File::Temp 'tempdir';
use File::Basename;
use File::Spec::Functions 'catfile', 'rel2abs', 'abs2rel';
use Cwd 'realpath', 'getcwd';
use lib dirname(realpath($0));
use Parallel::ForkManager;
use MovePaths;



# Globals
my $processpool;



# Command line args
my $parser = Getopt::ArgParse->new_parser(
	prog => "noledge",
	description => "Structure knowledge using LaTex, GraphViz and HTML.",
);
my $subparsers = $parser->add_subparsers(title => "command");

# Build
my $build_parser = $subparsers->add_parser(
	"build",
	help => "HTML entries",
	description => "Build all entries found in a given root directory.\n" .
	"Entry is defined as a directory containing at least a content.tex and a graph.gv file.\n"
);
$build_parser->add_arg(
	"root",
	help => "All entries found in this directory will be build."
);
$build_parser->add_arg(
	"--jobs",
	"-j",
	default => 1,
	help => "How many processes to use for building."
);
$build_parser->add_arg(
	"--quick",
	type => "Bool",
	default => 0,
	help => "If set, latex will be run once only, e.g. references might be wrong."
);

# Move
my $move_parser = $subparsers->add_parser(
	"move",
	help => "entry with automatic path adjustment.",
	description => "Move a single entry to another location.\n" .
	"Paths in all relevant files (tex, gv, html, map) are automatically adjusted\n" .
	"in all entries found in a given root directory."
);
$move_parser->add_arg(
	"source",
	help => "Directory containing at least a content.tex and graph.gv file."
);
$move_parser->add_arg(
	"target",
	help => "New name of the entry's directory."
);
$move_parser->add_arg(
	"root",
	help => "Paths identified in *.tex, *.gv, .*map, and *.html files found in\n" .
	"this directory will be adjusted accordingly."
);

# Find
my $find_parser = $subparsers->add_parser(
	"find",
	help => "Not implemented: entries that match all keywords."
);

# Initialize entry
my $init_parser = $subparsers->add_parser(
	"init",
	help => "Set up an empty entry."
);
$init_parser->add_arg(
	"directory",
	metavar => "DIR",
	help => "Where to set up the new entry."
);



# Parse cmd line arguments
my $cmdlineargs = $parser->parse_args();
unless (defined($cmdlineargs->current_command())) {
	$parser->print_usage();
	die;
}
if ($cmdlineargs->current_command() eq "build") {
	# Is directory?
	-d $cmdlineargs->root or die "Argument must be a directory";
	# Walk directory and build entries
	if ($cmdlineargs->jobs > 1) {
		$processpool = Parallel::ForkManager->new($cmdlineargs->jobs);
		$processpool->run_on_finish(\&forked_build_was_successful);
		find(\&run_build_entry_parallel, ( rel2abs($cmdlineargs->root) ));
		$processpool->wait_all_children();
	}
	elsif ($cmdlineargs->jobs == 1) {
		find(\&run_build_entry, ( rel2abs($cmdlineargs->root) ));
	}
	else {
		die "Number of jobs must be positive"
	}
}
elsif ($cmdlineargs->current_command() eq "move") {
	unless (-d $cmdlineargs->source and ! -e $cmdlineargs->target and -d $cmdlineargs->root) {
		die "Source must be directory and target must be non-existent";
	}
	move_entry(rel2abs($cmdlineargs->source), rel2abs($cmdlineargs->target), rel2abs($cmdlineargs->root));
}
elsif ($cmdlineargs->current_command() eq "find") {
	die "Not implemented";
}
elsif ($cmdlineargs->current_command() eq "init") {
	initialize_entry($cmdlineargs->directory);
}




# Subroutines
sub is_entry {

	my $entry = shift;

	# Is valid directory?
	return 0 unless (-d $entry and substr($entry, 0, 1) ne ".");

	# Check if directory contains required files
	return 0 unless (-f catfile($entry, "content.tex") and -f catfile($entry, "graph.gv"));

	return 1;
}
sub forked_build_was_successful {
	my ($pid, $exit_code, $entry) = @_;
	$exit_code and die "Build of $entry was not successful, exit code $exit_code";
}
sub run_build_entry {

	my $entry = $File::Find::name;
	return unless is_entry($entry);
	build_entry($entry);
}
sub run_build_entry_parallel {

	my $entry = $File::Find::name;
	return unless is_entry($entry);

	# Build entry in forked process
	$processpool->start($entry) and return;
	build_entry($entry);
	$processpool->finish();
}



=item build_entry
Routine to generate an HTML (+CSS) entry from a tex and gv file.
Argument: directory containing the above files.
=cut
sub build_entry {

	my $directory = shift;

	-d $directory or die "Argument must be a directory";
	my $wd = getcwd();
	chdir($directory) or die "Could not cd to $directory";

	(-f "content.tex" and -f "graph.gv") or
	die "content.tex or graph.gv missing";

	# Defines
	my $msg = "Error processing \"$directory\":";

	# Create build dir
	if (! -d "build") { mkdir("build"); }
	# Create css file if non-existant
	# Note that the user can define a custom one, it won't be overwritten
	if (! -e "entry.css") {
		open(FH, ">", "entry.css") or die "$msg Could not open entry.css for writing";
		print(FH
			".graph {\n" .
			"	display: block;\n" .
			"	margin-right: auto;\n" .
			"	margin-left: auto;\n" .
			"	margin-top: 2cm;\n" .
			"	margin-bottom: 2.5cm;\n" .
			"}\n" .
			".content {\n" .
			"	display: block;\n" .
			"	margin-right: auto;\n" .
			"	margin-left: auto;\n" .
			"	margin-top: 0cm;\n" .
			"	margin-bottom: 2cm;\n" .
			"}\n"
		);
		close(FH);
	}

	# Check what was changed; for later use
	my $graph_changed;
	{
		my $age = -M "graph.gv";
		$graph_changed = !(
			(-f "build/graph.svg" and $age >= -M "build/graph.svg") and
			(-f "build/graph.map" and $age >= -M "build/graph.map")
		);
	}
	my $content_changed;
	{
		my $age = -M "content.tex";
		$content_changed = !(-f "build/content.svg" and $age >= -M "build/content.svg");
	}

	# Check if something must be done
	unless ((! -e "entry.html") or $content_changed or $graph_changed) {
		chdir($wd) or die "Could not cd to $wd";
		return;
	}

	# Compile graph
	if ($graph_changed) {
		if (
		system("dot -Tsvg graph.gv -o build/graph.svg") or
		system("dot -Tcmapx graph.gv -o build/graph.map")
		) {
			die "$msg Could not compile \"graph.gv\".";
		}
	}
	# Read code of graph map for later integration into the html
	my $htmlgraph;
	{
		my $graphmap;
		open(FH, "<", "build/graph.map") or die "$msg Could not open graph map file";
		read(FH, $graphmap, -s FH);
		close(FH);
		$graphmap =~ s/\s+$//; # Strip right
		$htmlgraph =
			"<IMG SRC=\"build/graph.svg\" USEMAP=\"\#G\" class=\"graph\">\n$graphmap";
	}

	# Compile tex
	my $htmlcode;
	if ($content_changed) {
		# How often to run latex?
		my $runs = 2;
		if ($cmdlineargs->quick) { $runs = 1; }
		# Run latex
		if (system(
			#--no-shell-escape 
			('latex --output-format=dvi --output-dir=build content.tex && ' x $runs) . # TODO: Sure that is required?
			'dvisvgm --page=2 --linkmark=none -n build/content.dvi --output=build/%f.svg'
		)) { die "$msg Could not compile \"content.tex\""; }
	}
	# Read compiled content for later integration into html
	my $htmlcontent;
	{
		open(FH, "<", 'build/content.svg') or die "$msg Could not open content html file $_";
		read(FH, $htmlcontent, -s FH);
		close(FH);
		# Insert class to center content
		my $keyword = "<svg ";
		my $i = index($htmlcontent, $keyword);
		substr($htmlcontent, $i + length($keyword), 0) = 'class="content" ';
	}
	
	# Write html to file (here it is known that graph or content changed
	open(FH, ">", "entry.html") or die "$msg Could not write html file";
	print(FH
		"<!DOCTYPE html>\n" .
		"<html lang=\"en-US\">\n" .
		"<head>\n" .
		"<title>TODO</title>\n" .
		"<meta charset=\"utf-8\" />\n" .
		"<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n" .
		"<link rel=\"stylesheet\" type=\"text/css\" href=\"entry.css\" />\n" .
		"</head>\n" .
		"<body>\n" .
		$htmlgraph .
		"\n".
		$htmlcontent .
		"\n</body>\n".
		"</html>\n"
	);
	close(FH);
	# Go back to working directory
	chdir($wd) or die "Could not cd to $wd";
}



=item move_entry
=cut
sub move_entry {
	# Get arguments
	my ($source, $target, $root) = @_;
	$source = realpath($source);
	$target = realpath($target);
	$root = realpath($root);

	find(MovePaths::subroutine_for_find("entry\\.html", $source, $target, \&separators), ($root));
	make_path(dirname($target));
	move($source, $target) or die "Could not move entry $source";
}

=item separators
=cut
sub separators {
	my $ext;
	{
		my ($name) = @_;
		$name =~ /\.([^.]+)$/;
		$ext = $1;
	}

	my $start;
	my $end;
	if ($ext eq "tex") {
		$start = "\{";
		$end = "\}";
	}
	elsif ($ext =~ /(gv|map|html)/) {
		$start = "\"";
		$end = "\"";
	}
	elsif ($ext =~ /(svg|css)/) {
		system("touch ${File::Find::name}");
	}
	else {
		return;
	}
	return ($start, $end);
}



sub initialize_entry {

	my $dir = shift;

	die "$dir already exists" if (-e $dir);
	die "Parent directory of $dir must exist" if (! -e dirname($dir));

	mkdir($dir);

	open(FH, ">", "$dir/content.tex");
	print(FH
		"\\documentclass{article}\n" .
		"\\usepackage[hypertex]{hyperref}\n\n" .
		"\\title{}\n" .
		"\\author{}\n" .
		"\\date{}\n\n" .
		"\\begin{document}\n" .
		"\\pagenumbering{gobble}\n" .
		"\\vbox{\n" .
		"	\\maketitle\n\n" .
		"}\n" .
		"\\end{document}\n"
	);
	close(FH);

	open(FH, ">", "$dir/graph.gv");
	print(FH "digraph G {\n\n}\n");
	close(FH);
}

